HW1
Problem(1)
1. => O(log2(n))
2. Count of FuncB visits:
FuncB visits 2 times [visit of(n-1)] + 1 call for C(0) + itself call
C(n) = 2 C(n-1) + 2 
= 2 ( 2 C(n-2) + 2 ) + 2 = 2 ( 2 ( 2 C(n-3) + 2 ) + 2 ) + 2
= 2^k C(n-k) + 2^(k) + 2^(k-1) + ..+ 2
= 2^n C(0) + 2^n + 2^(n-1) + ... + 2
= 2^n + (2 + 4 + 8 + ... + 2^n)
= 2^n + 2(1-2^(n))/(1-2)= 2^n + 2(2^n-1) = 2^n(1-2)-2=3x2^n-2
=> O(2^n)
3. outer loop: log2(n)  inner loop:  2 + 4 +...+ 2^(log2(n))
log2(n)+ 2( 2^(log2(n)) -1 ) = log2(n) + 2n - 2;
=>O(n)


Problem(2)
1. (,(,1,2,+,),(3,(4,5,x,),+,),x,),(,(,9,3,/,),(,7,5,x,),+,),+

human: ((1+2)x(3+(4x5)))+((9/3)+(7x5))
post fix:=>
 ((1+2)x(3+(4x5))),((9/3)+(7x5)),+
 =>
  ((1+2), (3+(4x5)), x ),((9/3), (7x5), +),+
 =>
 ((1, 2, + ), (3, (4x5), +), x ),((9, 3, /), (7, 5, x), +),+
 =>
  ((1, 2, + ), (3, (4, 5, x), +), x ),((9, 3, /), (7, 5, x), +),+
   =>
  (,(,1,2,+,),(,3,(,4,5,x,),+,),x,),(,(,9,3,/,),(,7,5,x,),+,),+

2. 1,2,+,5,3,−,×,6,×,5,/
=> (1+2),(5-3),x,6,x,5,/
=>((1+2)x(5-3)),6,x,5,/
=>((1+2)x(5-3))x6,5,/
=>(((1+2)x(5-3))x6)/5

3. 
e1 => 1, ., ., .
e5 => 1, 5, ., .
e3 => 1, 5, 3, .
d  => ., 5, 3, .
e4 => ., 5, 3, 4
e6 => 6, 5, 3, 4
d  => 5, ., 3, 4

4.  
Two moves =>
(a) remove left 4p add right 9p
(b) remove left 2p add right 9p

Booster
Using stack to proceed the couples' IDs.
if the id is the same as the top of the stack, POP the stack
otherwise, PUSH the id to the stack
If resulting an empty stack, no intersections.
(a) 1, 2, 2, 1, 3, 3 
stacking procedures:
1 => 1
2 => 1, 2
2 => 1,
1 => .
3 => 3,
3 => .  => empty => no intersection
(b) 1, 2, 1, 2, 3, 3
1 => 1
2 => 1, 2
1 => 1, 2, 1
2 => 1, 2, 1, 2
3 => 1, 2, 1, 2, 3
3 => 1, 2, 1, 2 
not empty => intersections exist

5. Since we traverse each item one time each, the complexity is O(n)
6. Stacking operation on n items the complexity is exactly O(n)


Problem (3)
1.
a middle node pointer Middle is allocated and initialized with L.head
Traverse the chain with L.head <- L.head.next.
For every two traverse steps, update Middle to its next node
m <- L.head
i <- 0
while L.head != null
	i <- i+1
	if i % 2 == 0
		m <- m.next
	L.head <- L.head.next
2. 

bottom->nil
	foreach item in array
		if stack is empty
			bottom <- item
		else
			if item < top
				t <- POP stack
				if stack is empty
					bottom <- item;
				else
					if top = item 
						POP stack
					PUSH item
				PUSH t
			else if item > top
				PUSH item
5 => 5
2 => 5, 2      ( 2 < 5 && 2+1 != 5  push 2 )
1 => 5         ( 1 < 2 && 1+1 = 2, pop out 2 , 1 is smallest NO push 1)
1 => 5         ( 1 < 5  && 2+1 != 5   1 is smallest NO push 1)
2 =>> 2


3. 
a <-0
axd <-0
for i <- 1 to n
	a <- a + w[i]
	axd <- axd + i * w[i];
return Floor( axd / a )
